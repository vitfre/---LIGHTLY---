/*
 * keypad_3x4.h
 *
 * Created: 03.10.2013 16:04:14
 *  Author: vmk
 */ 

#ifndef	KEYPAD_3X4_H_
#define	KEYPAD_3X4_H_
//---------------------------------------------------------------------------------------
#define norm
//#define lin
//---------------------------------------------------------------------------------------
#include <avr/io.h>
#include "bit_macros.h"
//---------------------------------------------------------------------------------------
#define MASK_IN_KEYPAD 			(1<<_A_)|(1<<_B_)|(1<<_C_)|(1<<_D_)
#define MASK_OUT_KEYPAD 		(1<<_1_)|(1<<_2_)|(1<<_3_)
//---------------------------------------------------------------------------------------
//порт, к которому подключены ряды клавиатуры
#define PORT_IN_KEYPAD			PORTB
#define PIN_IN_KEYPAD			PINB
#define DDRX_IN_KEYPAD			DDRB
//порт, к которому подключены столбцы клавиатуры
#define PORT_OUT_KEYPAD			PORTC
#define PIN_OUT_KEYPAD			PINC
#define DDRX_OUT_KEYPAD			DDRC
//---------------------------------------------------------------------------------------
//номера выводов, к которым подключены ряды клавиатуры
#define _A_ 					7
#define _B_ 					6
#define _C_						5
#define _D_ 					4
//номера выводов, к которым подключены столбцы клавиатуры
#define _1_ 					2
#define _2_ 					1
#define _3_						0
//---------------------------------------------------------------------------------------
//коды, которые будут записываться в буфер
#define KEY_NUL      			0
#define KEY_1_     				1
#define KEY_2_    				2
#define KEY_3_					3
#define KEY_4_      			4
#define KEY_5_      			5
#define KEY_6_      			6
#define KEY_7_     				7
#define KEY_8_    				8
#define KEY_9_					9
#define KEY_STAR_				10
#define KEY_0_      			11
#define KEY_GRID_				12
//---------------------------------------------------------------------------------------
//сколько циклов опроса кнопка должна удерживаться
#define THRESHOLD_KEY			20
//---------------------------------------------------------------------------------------
volatile unsigned char pressKey = 0;
unsigned char trig_1_ = 0,trig_2_ = 0,trig_3_ = 0;
volatile unsigned char Key_dn=1;
/**************************************************************************
*   Function name : BUT_Init
*   Returns :       нет
*   Parameters :    нет
*   Purpose :       инициализация портов ввода/вывода
*                   вызывается обычно в начале main`a
****************************************************************************/
void KEY_Init(void)
{
	DDRX_IN_KEYPAD &=~ MASK_IN_KEYPAD;
	PORT_IN_KEYPAD |= MASK_IN_KEYPAD;
	
	DDRX_OUT_KEYPAD |= MASK_OUT_KEYPAD;
	PORT_OUT_KEYPAD |= MASK_OUT_KEYPAD;
};
/**************************************************************************
*   Function name : KEY_Debrief
*   Returns :       нет
*   Parameters :    нет
*   Purpose :       опрашивает кнопки. вызывается обычно из прерывания
*                   если кнопка нажата в течении 20 прерываний,
*                   ее номер записывается в буфер
****************************************************************************/
void KEY_Debrief(void)
{
	unsigned char key=0;
	switch(Key_dn)
	{
		case 1:
		{
			//---------------------------------------------------------------------------------------
			//последовательный опрос выводов мк
			if (BitVal(PIN_IN_KEYPAD, _A_)==0)
			{
				key = KEY_3_;
			}
			else if (BitVal(PIN_IN_KEYPAD, _B_)==0)
			{
				key = KEY_6_;
			}
			else if (BitVal(PIN_IN_KEYPAD, _C_)==0)
			{
					key = KEY_9_;
			}
			else if (BitVal(PIN_IN_KEYPAD, _D_)==0)
			{
				key = KEY_GRID_;
			}
			else
			{
				key = KEY_NUL;
			};
			//---------------------------------------------------------------------------------------
			//если во временной переменной что-то есть
			if (key)
			{
				//и если кнопка удерживается долго
				//записать ее номер в буфер
				if (trig_1_ == THRESHOLD_KEY)
				{
					trig_1_ = THRESHOLD_KEY+10;
					pressKey = key;
					return;
				}
				else if (trig_1_ < (THRESHOLD_KEY+5))
				{
					trig_1_++;
				};
			}
			else
			{
				trig_1_=0;
			};
			//---------------------------------------------------------------------------------------
			Key_dn=2;
			//---------------------------------------------------------------------------------------
		};break;
		case 2:
		{
			//---------------------------------------------------------------------------------------
			//последовательный опрос выводов мк
			if (BitVal(PIN_IN_KEYPAD, _A_)==0)
			{
				key = KEY_2_;
			}
			else if (BitVal(PIN_IN_KEYPAD, _B_)==0)
			{
				key = KEY_5_;
			}
			else if (BitVal(PIN_IN_KEYPAD, _C_)==0)
			{
				key = KEY_8_;
			}
			else if (BitVal(PIN_IN_KEYPAD, _D_)==0)
			key = KEY_0_;
			else
			{
				key = KEY_NUL;
			};
			//---------------------------------------------------------------------------------------
			//если во временной переменной что-то есть
			if (key)
			{
				//и если кнопка удерживается долго
				//записать ее номер в буфер
				if (trig_2_ == THRESHOLD_KEY)
				{
					trig_2_ = THRESHOLD_KEY+10;
					pressKey = key;
					return;
				}
				else if (trig_2_ < (THRESHOLD_KEY+5))
				{
					trig_2_++;
				};
			}
			else
			{
				trig_2_=0;
			};
			//---------------------------------------------------------------------------------------
			Key_dn=4;
			//---------------------------------------------------------------------------------------
		};break;
		case 4:
		{
			//---------------------------------------------------------------------------------------
			//последовательный опрос выводов мк
			if (BitVal(PIN_IN_KEYPAD, _A_)==0)
			{
				key = KEY_1_;
			}
			else if (BitVal(PIN_IN_KEYPAD, _B_)==0)
			{
				key = KEY_4_;
			}
			else if (BitVal(PIN_IN_KEYPAD, _C_)==0)
			{
				key = KEY_7_;
			}
			else if (BitVal(PIN_IN_KEYPAD, _D_)==0)
			{
				key = KEY_STAR_;
			}
			else
			{
				key = KEY_NUL;
			};
			//---------------------------------------------------------------------------------------
			//если во временной переменной что-то есть
			if (key)
			{
				//и если кнопка удерживается долго
				//записать ее номер в буфер
				if (trig_3_ == THRESHOLD_KEY)
				{
					trig_3_ = THRESHOLD_KEY+10;
					pressKey = key;
					return;
				}
				else if (trig_3_ < (THRESHOLD_KEY+5))
				{
					trig_3_++;
				};
			}
			else
			{
				trig_3_=0;
			};
			//---------------------------------------------------------------------------------------
			Key_dn=1;
			//---------------------------------------------------------------------------------------
		};break;
		default:Key_dn=1;
	};
	PORT_OUT_KEYPAD |= 0x7;
	PORT_OUT_KEYPAD &=~ Key_dn; //Выбираем следующий разряд
};
/**************************************************************************
*   Function name : KEY_GetKey
*   Returns :       номер нажатой кнопки
*   Parameters :    нет
*   Purpose :       возвращает содержимое кнопочного буфера
*                   при этом буфер очищается
*                   вызывается обычно в main`e в цикле while
*
****************************************************************************/
unsigned char KEY_GetKey(void)
{
	unsigned char key = pressKey;
	pressKey = KEY_NULL;
	return key;
};
/**************************************************************************
*   Function name : KEY_SetKey
*   Returns :       нет
*   Parameters :    номер кнопки
*   Purpose :       записывает в кнопочный буфер значение
*                   требуется иногда для имитации нажатия кнопок
****************************************************************************/
void KEY_SetKey(unsigned char key)
{
	pressKey = key;
};
#endif //KEYPAD_3X4_H_
