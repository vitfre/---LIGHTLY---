
#include "main.h"
#include <avr/io.h>

//Инициализация микроконтроллера

void mcu_init_ports(void)		/*Настойка портов*/
{
	/*
	ddr(x) - задает чем будет вывод:
	1 - выход
	0 - вход

	port(x) - включает подтяжку входа:
	1 - подтяжка включена
	0 - подтяжка выключена
	значение 0 так же устанавливает выход в 0 при включении мик-ра, если 
	вывод сконфигурирован выходом, а 1 включает выход относительно минуса питания*/

	DDRC  = 0b00001000;       //если 0 значит вход
	PORTC = 0b11110111;       //если 1 подтяжка включена

	DDRB  = 0b00001110;
	PORTB = 0b11110001;

	DDRD  = 0b01111111;
	PORTD = 0b10000000;

}
void mcu_init_timer0(void)		/*Настройка таймера TCNT0*/
{
	/*
	TIFR0 - регистр флагов прерываний
			OCF0B - флаг прерывания регистра сравнения OCR0B
			OCF0A - флаг прерывания регистра сравнения OCR0A
			TOV0  - флаг прерывания счетного регистра TCNT0
	TCNT0 - восьмиразрядный счетный регистр таймера
	OCR0A - восьмиразрядный регистр сравнения A
	OCR0B - восьмиразрядный регистр сравнения B*/

	//GTCCR=(0<<TSM)|(0<<PSRSYNC);
	/*GTCCR - управление предделителем таймера
			TSM - при записи лог. 1 останавливаются все предделители
			таймеров. Запуск предделителей осуществляется записью лог. 0.
			После сброса TSM биты PSRSYNC и PSRASY аппаратно сбрасываются
			если там были выставлены лог. 1. И таймеры начинают работать 
			одновременно.
			PSRSYNC - при записи лог. 1 предделители таймеров Т0 и Т1
			будут сброшены. После сброса бит аппаратно вернется в 0.*/
	
	TCCR0A=(0<<COM0A1)|(0<<COM0A0)|(0<<COM0B1)|(0<<COM0B0)|(1<<WGM01)|(0<<WGM00);  	
	/*
	TCCR0A - регистр A управления таймером счетчиком

			COM0A0 - эти два бита управляют режимом работы выхода OC0A 
			COM0A1 - эти два бита управляют режимом работы выхода OC0A 
		
			COM0B0 - эти два бита управляют режимом работы выхода OC0B
			COM0B1 - эти два бита управляют режимом работы выхода OC0B
		
			WGM01  - выбор режима работы таймера счетчика 
			WGM00  - выбор режима работы таймера счетчика 

	Mode      WGM02      WGM01      WGM00  Timer/Counter          TOP    Update of     TOV Flag
										   Mode of                        OCRx at      Set on
										   Operation 
	--------------------------------------------------------------------------------------------
	  0			0		   0		  0     Normal                0xFF    Immediate     MAX
	  1         0          0          1     PWM, Phase Correct    0xFF    TOP           BOTTOM
	  2         0          1          0     CTC                   OCRA    Immediate     MAX
	  3         0          1          1     Fast PWM              0xFF    BOTTOM        MAX
	  4         1          0          0     Reserved
	  5         1          0          1     PWM, Phase Correct    OCRA    TOP           BOTTOM
	  6         1          1          0     Reserved
	  7         1          1          1     Fast PWM              OCRA    BOTTOM        TOP*/

	OCR0A=0x47;
	TCCR0B=(0<<FOC0A)|(0<<FOC0B)|(0<<WGM02)|(1<<CS02)|(0<<CS01)|(1<<CS00);	
	/*
	TCCR0B - регистр B управления таймером счетчиком
			 FOC0A - принудительное изменение состояние вывода OC0A 
			 только для режимов Normal и CTC
			 FOC0B - принудительное изменение состояние вывода OCR0B
			 только для режимов Normal и CTC
			 WGM02  - выбор режима работы таймера счетчика 
			 CS02 - настройка предделителя
			 CS01 - настройка предделителя
			 CS00 - настройка предделителя
	000-таймер выкл, 001-1, 010-8, 011 - 64, 100 - 256, 101 - 1024*/

	TIMSK0=(1<<OCIE0A)|(0<<OCIE0B)|(0<<TOIE0); 
	/*
	TIMSK0 - установка разрешений прерываний
			 OCIE0A - по совпадению регистра совпадения с регистром счета OCR0A 
			 OCIE0B - по совпадению регистра совпадения с регистром счета OCR0B
			 TOIE0  - по переполнению счетного регистра TCNT0 */
}
void mcu_init_timer1(void)		/*Настройка таймера TCNT1*/
{
	/*	ICR1  - 16-ти битный  регистр захвата
	OCR1B - 16-ти битный  регистр сравнения
	OCR1A - 16-ти битный  регистр сравнения
	TCNT1 - 16-ти битный счетный регистр таймера
	TIFR1  - регистр флагов прерываний
			ICF1  - флаг прерывания регистра захвата ICR1
			OCF1A - флаг прерывания регистра сравнения OCR1A
			OCF1B - флаг прерывания регистра сравнения OCR1В
			TOV1  - флаг прерывания счетного регистра TCNT1*/

	//GTCCR=(0<<TSM)|(0<<PSRSYNC);
	/*GTCCR - управление предделителем таймера
			TSM - при записи лог. 1 останавливаются все предделители
			таймеров. Запуск предделителей осуществляется записью лог. 0.
			После сброса TSM биты PSRSYNC и PSRASY аппаратно сбрасываются
			если там были выставлены лог. 1. И таймеры начинают работать 
			одновременно.
			PSRSYNC - при записи лог. 1 предделители таймеров Т0 и Т1
			будут сброшены. После сброса бит аппаратно вернется в 0.*/	 
			
	TCCR1A= (0<<COM1A1)|(0<<COM1A0)|(0<<COM1B1)|(0<<COM1B0)|(0<<WGM11)|(0<<WGM10);  
	/*TCCR1A - регистр А управления таймером счетчиком

		COM1A1 - эти два бита управляют режимом работы выхода OC1A      
		COM1A0 - эти два бита управляют режимом работы выхода OC1A   
	   
		COM1B1 - эти два бита управляют режимом работы выхода OC1В      
		COM1B0 - эти два бита управляют режимом работы выхода OC1В 
	
		WGM11...WGM10 - выбор режима работы таймера счетчика  */

	TCCR1B=(0<<ICNC1)|(0<<ICES1)|(0<<WGM13)|(0<<WGM12)|(0<<CS12)|(0<<CS11)|(0<<CS10);
	/* TCCR1B - регистор B управления таймером счетчиком

		   ICNC1 - разрешение работы шумоподавителя на входе захвата.         
		   ICES1 – выбор активного фронта сигнала захвата.
	
		   WGM13...WGM12 - выбор режима работы таймера счетчика    
	        
		   CS12...CS10 - настройка предделителя.
	    
	000 - стоп, 001-1, 010-8, 011-64, 100-256, 101-1024, 110-внешнее тактирование UP  
														 111-внешнее тактирование DOWN


	Mode     WGM13   WGM12   WGM11    WGM10  Timer/Counter                        Mode of TOP  Update of    TOV1 Flag 
					 (CTC1)  (PWM11) (PWM10)  Operation                                         OCR1x        Set on
 
	 0         0       0        0       0      Normal                               0xFFFF     Immediate     MAX
	 1         0       0        0       1      PWM, Phase Correct, 8-bit            0x00FF     TOP           BOTTOM
	 2         0       0        1       0      PWM, Phase Correct, 9-bit            0x01FF     TOP           BOTTOM
	 3         0       0        1       1      PWM, Phase Correct, 10-bit           0x03FF     TOP           BOTTOM
	 4         0       1        0       0      CTC                                  OCR1A      Immediate     MAX
	 5         0       1        0       1      Fast PWM, 8-bit                      0x00FF     BOTTOM        TOP
	 6         0       1        1       0      Fast PWM, 9-bit                      0x01FF     BOTTOM        TOP
	 7         0       1        1       1      Fast PWM, 10-bit                     0x03FF     BOTTOM        TOP
	 8         1       0        0       0      PWM, Phase and Frequency Correct     ICR1       BOTTOM        BOTTOM
	 9         1       0        0       1      PWM, Phase and Frequency Correct     OCR1A      BOTTOM        BOTTOM
	 10        1       0        1       0      PWM, Phase Correct                   ICR1       TOP           BOTTOM
	 11        1       0        1       1      PWM, Phase Correct                   OCR1A      TOP           BOTTOM
	 12        1       1        0       0      CTC                                  ICR1       Immediate     MAX
	 13        1       1        0       1      (Reserved)                           –          –             –
	 14        1       1        1       0      Fast PWM Переменная (2...16)         ICR1       BOTTOM        TOP
	 15        1       1        1       1      Fast PWM Переменная (2...16)         OCR1A      BOTTOM        TOP*/

	TCCR1C=(0<<FOC1A)|(0<<FOC1B);
	/*
	FOC1A - принудительное изменение состояние вывода OC1A 
	только для режимов Normal и CTC
	FOC1B - принудительное изменение состояние вывода OC1B
	только для режимов Normal и CTC*/

	TIMSK1=(0<<OCIE1A)|(0<<OCIE1B)|(0<<TOIE1)|(0<<ICIE1);		
	/*
	TIMSK1 - установка разрешений прерываний
		TOIE1  - по переполнению счетного регистра TCNT1                   
		OCIE1B - по совпадению регистра совпадения с регистром счета OCR1B
		OCIE1A - по совпадению регистра совпадения с регистром счета OCR1A 
		ICIE1  - по захвату регистра ICR1*/ 
}
void mcu_init_timer2(void)		/*Настройка таймера TCNT2*/ 
{
	/*
OCR2A - восьмиразрядный регистр сравнения A
OCR2B - восьмиразрядный регистр сравнения B
TCNT2 - восьмиразрядный счетный регистр таймера
TIFR2 - регистр флагов прерываний
		OCF2B - флаг прерывания регистра сравнения OCR2B      
		OCF2A - флаг прерывания регистра сравнения OCR2A          
		TOV2  - флаг прерывания счетного регистра TCNT2*/	
	
	//GTCCR=(0<<TSM)|(0<<PSRASY);
	/*GTCCR - управление предделителем таймера
			TSM - при записи лог. 1 останавливаются все предделители
			таймеров. Запуск предделителей осуществляется записью лог. 0.
			После сброса TSM биты PSRSYNC и PSRASY аппаратно сбрасываются
			если там были выставлены лог. 1. И таймеры начинают работать 
			одновременно.
			PSRASY - при записи лог. 1 предделители таймера Т2
			будет сброшен. После сброса бит аппаратно вернется в 0.*/		
					
	TCCR2A=(0<<COM2A1)|(0<<COM2A0)|(0<<COM2B1)|(0<<COM2B0)|(0<<WGM21)|(0<<WGM20);
	/*
	TCCR2A - регистр А управления таймером счетчиком

		COM2A1 - эти два бита управляют режимом работы выхода OC1A      
		COM2A0 - эти два бита управляют режимом работы выхода OC1A   
	   
		COM2B1 - эти два бита управляют режимом работы выхода OC1В      
		COM2B0 - эти два бита управляют режимом работы выхода OC1В 
	
		WGM22...WGM20 - выбор режима работы таймера счетчика*/

	TCCR2B=(0<<FOC2A)|(0<<FOC2B)|(0<<WGM22)|(1<<CS22)|(0<<CS21)|(0<<CS20);
	/*
	TCCR2B - регистр B управления таймером счетчиком
			FOC2A - принудительное изменение состояние вывода OC2A 
			только для режимов Normal и CTC
			FOC2B - принудительное изменение состояние вывода OC2B
			только для режимов Normal и CTC
			WGM22...WGM20 - выбор режима работы таймера счетчика
			CS22...CS20   - настройка предделителя.
	000 - выкл, 001-0, 010-8, 011 - 32, 100 - 64, 101 - 128, 110 - 256, 111 - 1024
	16000 тактов это 2 мсек. 16000/64=250 загружаем в регистр сравнения.*/
	OCR2A=250;

	ASSR=(0<<EXCLK)|(0<<AS2)|(0<<TCN2UB)|(0<<OCR2AUB)|(0<<OCR2BUB)|(0<<TCR2AUB)|(0<<TCR2BUB); 
	/*EXCLK  - при лог.1 таймер тактируется только от ножки TOSC1. Бит должен быть установлен
	   до установки бита AS2. Кварцевый внешний генератор будет работать только, когда этот 
	   бит равен нулю.    
	 AS2      - включение таймера в ассинхронном режиме от внешнего кварца.  
	 TCN2UB   - флаг регистра  TCNT2   
	 OCR2AUB  - флаг регистра  OCR2A    
	 OCR2BUB  - флаг регистра  OCR2B   
	 TCR2AUB  - флаг регистра  TCCR2A    
	 TCR2BUB  - флаг регистра  TCCR2B*/
 
	/*Для включения надо всего лишь установить бит AS2 регистра ASSR - и все, таймер работает в асинхронном
	режиме. Но есть тут одна фича которая мне стоила много головняков в свое время. Дело в том, что при работе
	от своего кварца все внутренние регистры таймера начинают синхронизироваться по своему же кварцу. А он
	медленный и основная программа может менять уже введенное значение гораздо быстрей чем оно обработается
	таймером.
	Т.е., например, предустановил ты значение TCNT2, таймер на своей 32кгц молотилке его еще даже прожевать
	не успел, а твой алгоритм уже пробежал и снова туда что то записал — в результате в TCNT2 наверняка попадет
	мусор. Чтобы этого не случилось запись буфферизируется. Т.е. это ты думаешь, что записал данные в TCNT2,
	но на самом деле они попадают во временный регистр и в счетный попадут только через три такта медленного
	генератора.
	Также буфферизируется регистры сравнения OCR2 и регистр конфигурации TCCR2
	Как узнать данные уже внеслись в таймер или висят в промежуточных ячейках? Да очень просто - по флагам в
	регистре ASSR. Это биты TCN2UB, OCR2UB и TCR2UB - каждый отвечает за свой регистр. Когда мы, например,
	записываем значение в TCNT2 то TCNUB становится 1, а как только наше число из промежуточного регистра
	таки перешло в реальный счетный регистр TCNT2 и начало уже тикать, то этот флаг автоматом сбрасывается.
	Таким образом, в асинхронном режиме, при записи в регистры TCNT2, OCR2 и TCCR2 сначала нужно проверять
	флаги TCN2UB, OCR2UB и TCR2UB и запись проводить только если они равны нулю. Иначе результат может быть
	непредсказуемым.*/
 
	TIMSK2=(0<<OCIE2B)|(1<<OCIE2A)|(0<<TOIE2);
	/*
	TIMSK2 - установка разрешений прерываний
			TOIE2  - по переполнению счетного регистра TCNT2                   
			OCIE2B - по совпадению регистра совпадения с регистром счета OCR2B
			OCIE2A - по совпадению регистра совпадения с регистром счета OCR2A*/ 
}
void mcu_init_adc(void)			/*Настройка АЦП*/    
{
	//ADC - 16 ти битный регистр данных замера с любого канала АЦП

	ADCSRA=(1<<ADEN)|(1<<ADSC)|(0<<ADATE)|(0<<ADIF)|(0<<ADIE)|(1<<ADPS2)|(1<<ADPS1)|(0<<ADPS0);   
	/*
	ADEN - включаем АЦП         
	ADSC - запускаем первое преобразование(дальше вручную, этот же бит).Когда этот бит 
			стал = 0. преобразование закончено.       
	ADATE- лог. 0 отключаем непрерывное преобразование          
	ADIF - флаг прерывания по окончанию преобразования
	ADIE - разрешение прерывания по окончанию преобразования        
	ADPS2...ADPS1...ADPS0 - выставляем частоту работы ядра АЦП оптимально от 50-200 кГц.   
	8000кГц/64 = 125кГц в диапазон уложились.
        
	ADPS2 ADPS1 ADPS0 Division Factor
	  0     0     0        2
	  0     0     1        2
	  0     1     0        4
	  0     1     1        8
	  1     0     0        16
	  1     0     1        32
	  1     1     0        64
	  1     1     1        128*/

	//ADCSRB=(0<<ACME)|(0<<ADTS2)|(0<<ADTS1)|(0<<ADTS0); 
	/*
	ACME -  смотри аналоговый компаратор.
	ADTS2 ADTS1 ADTS0  ИСТОЧНИК СТАРТОВОГО СИГНАЛА      
	  0		0	 0      Режим непрерывного преобразования
	  0		0    1		Прерывание от аналогового компаратора
	  0		1    0		Внешнее прерывание INT0
	  0		1    1		Прер. по событию совпадение А Таймера Т0
	  1		0    0		Прер. по переполнению Т0
	  1		0    1		Прер. по событию "совпадение" В Таймера Т1
	  1		1    0		Прер. по переполнению Т1
	  1		1    1		Прер. по событию "захват" Т1
	Это возможные варианты запуска преобр. АЦП от разных источников.*/

	ADMUX=(0<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0<<MUX3)|(0<<MUX2)|(0<<MUX1)|(0<<MUX0);
	/*
	REFS1...REFS0 - выбор источника опорного напряжения      
 
	REFS1       REFS0   ИСТОЧНИК ОПОРНОГО НАПРЯЖЕНИЯ
	 0           0      внешний ИОН, подкл. к выводу AREF, внутр. ИОН отключен.
	 0           1      от напряжения питания
	 1           0      Резерв
	 1           1      Внутр. ИОН напряжением 1.1 V
     
	ADLAR - если лог. 1 то выравнивание по левому краю если 0 то по правому.

	MUX3..0 выбор входного канала 
	 0000		ADC0
	 0001		ADC1
	 0010		ADC2
	 0011		ADC3
	 0100		ADC4
	 0101		ADC5
	 0110		ADC6
	 0111		ADC7
	 1110       1.1V (VBG)подключаем к АЦП внутренний источник опорного 
				напряжения на 1.1 вольта.(для калибровки) 
	 1111       0V (GND) сажаем канал АЦП изнутри на землю, (для выявления шумов)*/

	DIDR0=(0<<ADC5D)|(1<<ADC4D)|(0<<ADC3D)|(0<<ADC2D)|(1<<ADC1D)|(1<<ADC0D);   
	//Отключение каналов АЦП. Когда записана лог. 1 соотв. канал отключен.
}
void mcu_init_an_comp(void)		/*Аналоговый компаратор*/
{
	ACSR=(1<<ACD)|(0<<ACBG)|(0<<ACO)|(0<<ACI)|(0<<ACIE)|(0<<ACIC)|(0<<ACIS1)|(0<<ACIS0);
	/*
	ACD - включение компаратора 0-включен, 1-выключен
	ACBG - Подключение к неинв. входу (AIN0) внутренний ИОН 0-не подключен 1-подключен
	ACO - если AIN0>AIN1, тогда ACO = 1.
	ACI - флаг прерывания
	ACIE - разрешение прерывания
	ACIC - подкл. к блоку захвата Т1

	Условия генрации прерывания         
	ACIS1  ACIS0 
	 0       0      любое изменение ACO
	 0       1      резерв
	 1       0      с 1 на 0
	 1       1      с 0 на 1
	 Если U на AIN1 < чем на AIN0 тогда выход компаратора ACO будет равен 1 
	 и наоборот.*/ 
}
void mcu_init_ext_int(void)		/*Настройка внешних прерываний INT0, INT1*/
{
	EIMSK=(0<<INT1)|(0<<INT0);
	//INT1 разрешение на прерывание с INT1
	//INT0 разрешение на прерывание с INT0

	EICRA=(0<<ISC11)|(0<<ISC10)|(0<<ISC01)|(0<<ISC00);
	/*
	ISC11  ISC10 - настройка прерывания INT1 
	  0      0     по НИЗКОМУ уровню
	  0      1     при любом логическом изменении
	  1      0     по спадающему фронту на выводе
	  1      1     по нарастающему фронту на выводе

	ISC01   ISC00 - настройка прерывания INT0
	  0      0     по НИЗКОМУ уровню
	  0      1     при любом логическом изменении
	  1      0     по спадающему фронту на выводе
	  1      1     по нарастающему фронту на выводе*/
	
	PCICR=(0<<PCIE2)|(1<<PCIE1)|(0<<PCIE0);
	/*
	PCIE2 - Разрешение прерывания по изменению состояния выводов 2й группы. если в этом
			бите записана лог. 1 и флаг I=1, то разрешается внешнее прерывание по изменению
			состояния выводов PCINT23...16 мк. К возникновению прерывания приводит любое
			изменение сигнала на любом выводе.         
	PCIE1 - Разрешение прерывания по изменению состояния выводов 2й группы. если в этом
			бите записана лог. 1 и флаг I=1, то разрешается внешнее прерывание по изменению
			состояния выводов PCINT14...8 мк. К возникновению прерывания приводит любое
			изменение сигнала на любом выводе.         
	PCIE0 -  Разрешение прерывания по изменению состояния выводов 2й группы. если в этом
			бите записана лог. 1 и флаг I=1, то разрешается внешнее прерывание по изменению
			состояния выводов PCINT7...0 мк. К возникновению прерывания приводит любое
			изменение сигнала на любом выводе. */

	PCMSK0=(0<<PCINT7)|(0<<PCINT6)|(0<<PCINT5)|(0<<PCINT4)|(0<<PCINT3)|(0<<PCINT2)|(0<<PCINT1)|(0<<PCINT0);  
	PCMSK1=(0<<PCINT14)|(1<<PCINT13)|(1<<PCINT12)|(0<<PCINT11)|(0<<PCINT10)|(0<<PCINT9)|(0<<PCINT8); 
	PCMSK2=(0<<PCINT23)|(0<<PCINT22)|(0<<PCINT21)|(0<<PCINT20)|(0<<PCINT19)|(0<<PCINT18)|(0<<PCINT17)|(0<<PCINT16); 
	/*
	PCMSK0 - Определяют условие генерации прерывания PCI0. Если какой-либо бит установлен в 1, 
			 то изменение состояния соответствующего вывода вызовет генерацию прервания.
	PCMSK1 - Определяют условие генерации прерывания PCI1. Если какой-либо бит установлен в 1, 
			 то изменение состояния соответствующего вывода вызовет генерацию прервания.
	PCMSK2 - Определяют условие генерации прерывания PCI2. Если какой-либо бит установлен в 1, 
			 то изменение состояния соответствующего вывода вызовет генерацию прервания.*/


	//EIFR=(0<<INTF1)|(0<<INTF0); //Регистр флагов внешних прерыаний
	//PCIFR=(0<<PCIF2)|(0<<PCIF1)|(0<<PCIF0); 
	/*
	PCIF2 - Флаг прерывания по изменению состояния выводов 2й группы. если в результате
			события на любом из выводов PCINT23...16 сформировался запрос на прерывание
			, то этот бит уст. в 1. флаг сбросится аппаратно при запуске подпрограммы 
			обработки прерывания или программно, записью в него лог. 1.          
	PCIF1 - Флаг прерывания по изменению состояния выводов 2й группы. если в результате
			события на любом из выводов PCINT15...8 сформировался запрос на прерывание
			, то этот бит уст. в 1. флаг сбросится аппаратно при запуске подпрограммы 
			обработки прерывания или программно, записью в него лог. 1.            
	PCIF0 - Флаг прерывания по изменению состояния выводов 2й группы. если в результате
			события на любом из выводов PCINT7...0 сформировался запрос на прерывание
			, то этот бит уст. в 1. флаг сбросится аппаратно при запуске подпрограммы 
			обработки прерывания или программно, записью в него лог. 1.*/ 
}	
void mcu_init_wdt(void)			/*Настройка сторожевого таймера*/
{
	WDTCSR=(0<<WDIF)|(0<<WDIE)|(0<<WDP3)|(0<<WDCE)|(0<<WDE)|(0<<WDP2)|(0<<WDP1)|(0<<WDP0); 
	/*
	WDIF - флаг прерывания от сторожевого таймера.
	WDIE - Разрешение прерывания от сторожевого таймера.                  
	WDCE - разрешение изменения конфигурации сторожевого таймера.
	WDE  - Разрешение сброса по тайм-ауту сторожевого таймера.
	_________________
	FUSE      
	WDTON   WDE  WDIE         Режим           действие по тайм-ауту
	  1		 0	  0         Остановлен          Нет действий
	  1      0	  1			Режим прерывания    Прерывание
	  1      1    0			Режим сброса        Сброс
	  1      1    1			Режим прерывания    Прерывание затем преключение
							и сброса			в режим сброса.
	  0      x    x         Режим сброса        Сброс
	_________________

	Коэффициент деления предделителя сторожевого таймера.
	WDP3  WDP2   WDP1   WDP0 
	  0     0     0      0      2K (2048) cycles 16 ms
	  0     0     0      1      4K (4096) cycles 32 ms
	  0     0     1      0      8K (8192) cycles 64 ms
	  0     0     1      1      16K (16384) cycles 0.125 s
	  0     1     0      0      32K (32768) cycles 0.25 s
	  0     1     0      1      64K (65536) cycles 0.5 s
	  0     1     1      0      128K (131072) cycles 1.0 s
	  0     1     1      1      256K (262144) cycles 2.0 s
	  1     0     0      0      512K (524288) cycles 4.0 s
	  1     0     0      1      1024K (1048576) cycles 8.0 s


	*/

}
				





